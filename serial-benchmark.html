<html>
  <head>
    <title>Serial API Benchmark</title>
    <!-- Token for http://localhost:8080 -->
    <meta http-equiv="origin-trial" content="AsrFHrn2XwhF8DZL4iZiDW61icVp6hZN9z0iPQiG2Ptc64KAWozVcwVBvznRh7z4pxJ/3fK2vrGn0851VVpPmAcAAABJeyJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwODAiLCJmZWF0dXJlIjoiU2VyaWFsIiwiZXhwaXJ5IjoxNTkzMTMwNjA0fQ==">
    <!-- Token for https://reillyeon.github.io -->
    <meta http-equiv="origin-trial" content="AsT+JnbDRIlYh0EvFl9/HDfopcw16Z4aT3NjoEoWs7z87jIuHq1zfdd7sQOVThxVL5SWa6C1Mlu25psmgx7XCgoAAABTeyJvcmlnaW4iOiJodHRwczovL3JlaWxseWVvbi5naXRodWIuaW86NDQzIiwiZmVhdHVyZSI6IlNlcmlhbCIsImV4cGlyeSI6MTU5MzEzMDYzOH0=">
  </head>
  <body>
    <p>
      Baud rate: <input type="text" inputmode="numeric" pattern="[0-9]*" id="baud-rate" value="9600" required><br>
      Buffer size: <input type="text" inputmode="numeric" pattern="[0-9]*" id="buffer-size" value="255" required><br>
      Chunk size: <input type="text" inputmode="numeric" pattern="[0-9]*" id="chunk-size" value="1024" required><br>
      Average rate over <input type="text" inputmode="numeric" pattern="[0-9]*" id="rate-interval" value="1000" required> milliseconds.
    </p>
    <button id="connect">Connect</button>
    <button id="writer" disabled>Start Writer</button>
    <button id="reader" disabled>Start Reader</button>
    <p>
      Bytes sent: <span id="sent-count">0</span><br>
      Bytes received: <span id="received-count">0</span><br>
      Bandwidth delay product: <span id="bandwidth-delay-product">0</span><br>
      Outgoing rate: <span id="send-rate">0</span> bits/second<br>
      Incoming rate: <span id="receive-rate">0</span> bits/second<br>
    </p>

    <script>
      const baudRateEl = document.getElementById('baud-rate');
      const bufferSizeEl = document.getElementById('buffer-size');
      const chunkSizeEl = document.getElementById('chunk-size');
      const rateIntervalEl = document.getElementById('rate-interval');
      const connectButton = document.getElementById('connect');
      const writerButton = document.getElementById('writer');
      const readerButton = document.getElementById('reader');
      const sentCountEl = document.getElementById('sent-count');
      const receivedCountEl = document.getElementById('received-count');
      const bandwidthDelayProductEl = document.getElementById('bandwidth-delay-product');
      const outgoingRateEl = document.getElementById('send-rate');
      const incomingRateEl = document.getElementById('receive-rate');

      let port = null;
      let writing = false;
      let reading = false;

      let chunkSize = parseInt(chunkSizeEl.value);

      let rateIntervalMs = parseInt(rateIntervalEl.value);
      let rateIntervalId = -1;
      let previousSentCount = 0;
      let previousReceivedCount = 0;
      let sentCount = 0;
      let receivedCount = 0;

      function incrementCounts(sentIncrement, receivedIncrement) {
        sentCount += sentIncrement;
        receivedCount += receivedIncrement;

        const bandwidthDelayProduct = sentCount - receivedCount;

        sentCountEl.textContent = sentCount;
        receivedCountEl.textContent = receivedCount;
        bandwidthDelayProductEl.textContent = bandwidthDelayProduct;
      }

      function calculateRates() {
        const outgoingRate = (sentCount - previousSentCount) * 8 / (rateIntervalMs / 1000);
        const incomingRate = (receivedCount - previousReceivedCount) * 8 / (rateIntervalMs / 1000);

        previousSentCount = sentCount;
        previousReceivedCount = receivedCount;

        outgoingRateEl.textContent = outgoingRate;
        incomingRateEl.textContent = incomingRate;
      }

      async function writerLoop() {
        writerButton.textContent = 'Stop Writing';


        writing = true;

        while (writing && port && port.writable) {
          const writer = port.writable.getWriter();
          try {
            while (writing) {
              const buffer = new Uint8Array(chunkSize);
              await writer.write(buffer);
              incrementCounts(buffer.byteLength, 0);
            }
          } catch (e) {
            console.error(e);
          } finally {
            writer.releaseLock();
          }
        }

        writerButton.textContent = 'Start Writing';
        if (port) {
          writerButton.disabled = false;
        }
      }

      async function readerLoop() {
        readerButton.textContent = 'Stop Reading';

        reading = true;

        while (reading && port && port.readable) {
          const reader = port.readable.getReader();
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (value) {
                incrementCounts(0, value.byteLength);
              }
              if (done) {
                break;
              }
            }
          } catch (e) {
            console.error(e);
          } finally {
            reader.releaseLock();
          }
        }

        readerButton.textContent = 'Start Reading';
        if (port) {
          readerButton.disabled = false;
        }
      }

      async function connect() {
        connectButton.disabled = true;

        const baudrate = parseInt(baudRateEl.value);
        const buffersize = parseInt(bufferSizeEl.value);
        const options = { baudrate, buffersize };

        port = await navigator.serial.requestPort();
        await port.open(options);

        connectButton.textContent = 'Disconnect';
        connectButton.disabled = false;
        writerButton.disabled = false;
        readerButton.disabled = false;

        rateIntervalId = setInterval(calculateRates, rateIntervalMs);
      }

      async function disconnect() {
        connectButton.disabled = true;

        await port.close();
        port = null;

        connectButton.textContent = 'Connect';
        connectButton.disabled = false;
        writerButton.disabled = false;
        readerButton.disabled = false;

        clearInterval(rateIntervalId);
        rateIntervalId = -1;
      }

      connectButton.addEventListener('click', () => {
        if (port) {
          disconnect();
        } else {
          connect();
        }
      });

      writerButton.addEventListener('click', () => {
        if (writing) {
          writing = false;
          writerButton.disabled = true;
        } else {
          writerLoop();
        }
      });

      readerButton.addEventListener('click', () => {
        if (reading) {
          reading = false;
          readerButton.disabled = true;
        } else {
          readerLoop();
        }
      });

      rateIntervalEl.addEventListener('change', () => {
        rateIntervalMs = parseInt(rateIntervalEl.value);

        if (rateIntervalId != -1) {
          clearInterval(rateIntervalEl);
          rateIntervalId = setInterval(calculateRates, rateIntervalMs);
        }
      });

      chunkSizeEl.addEventListener('change', () => {
        chunkSize = parseInt(chunkSizeEl.value);
      })
    </script>
  </body>
</html>
